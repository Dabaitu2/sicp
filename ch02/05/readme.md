# Systems with Genric Operations

在本章我们主要是设计了一套通用的算术包，它是基于多重表示的抽象屏障和数据导向设计实现的

为了实现跨数据类型的运算，我们可能有多种候选策略

1. 在每个类型中实现它和其他类型的运算，这实现计算笛卡尔积个数的方法, 复杂度暴涨，因此不合适
2. 更好的办法便是使用 coercion (强制转换), 去将不同类型转化为同一类型再去处理，这样会在保持抽象屏障的同时，增加实用性
   a. 对于不同类型，可以先尝试着转为其中的某一种类型再应用过程
   b. 如果 a 行不通, 可以将两者转化为相同的第三者类型再尝试应用过程

   在一些类型中往往存在着一定的自然关系，一种典型的自然关系就是 *"层次关系"*
   例如 整数-有理数-实数-复数 他们是逐级变得更加宽泛的, 整数是一种特殊的**有理数**, 有理数是一种特殊的实数...
   形式化的说，整数是有理数的 subtype 子类型。而有理数是整数的 supertype 超类型。而如果我们要做的通用操作都满足
   这样的线性关系, 那么他们可以被称为是 类型塔。而我们便可以设计一个 "raise" 提升策略去让通用性操作去将某一个 subtype raise
   到 supertype 再去执行操作。使得 coercion 变得容易许多
  
   另一方面, 我们可以利用 raise 操作实现 "继承". 即使某个子类型没有某种方法. 但如果通过 raise 之后我们能够找到某个超类型具有
   对应方法, 那么就可以调用超类型的方法来实现了!

   相对于 raise, 我们自然也有相反的操作 "lower" 即下降。通过下降我们可以使得计算的结果达到最简表达形式
   例如 `2+3i` 与 `3-4i` 的加法结果可以化简为 0。当然这样的操作需要有通用方式去判断是否可以 lower。

   不过需要注意到的事，现实世界中不是所有的类型都满足类型塔关系，有很多的关系是相互交错的，例如正方形又是矩形又是菱形。但这两者又都是平行四边形
   这种情况下, 我们要做到下降和上升就比较困难了, 因为需要大范围的搜索，这也是很多编程语言不支持多继承的缘故之一吧！
