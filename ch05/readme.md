# Computing with Register Machines

> 使用寄存器进行计算



本书研究计算过程 (Computational Process, 参见第一章), 并通过 Lisp 写出的过程 (procedures) 来描述计算过程.

为了解释这些过程 (procedures) 的意义 (这样我们才能知道为什么这个过程可以描述计算过程).  

第一章我们介绍了 代换模型(the substitution model),  第三章介绍了环境模型(the environment model), 第四章介绍了元循环解释器 (the metacircular evaluator),   特别是我们对元循环求值器的研究，消除了类似Lisp语言如何解释的许多谜团。

然而, 即使是元循环求值器也留下了一些没有能够被解决的问题: 它没有阐明 Lisp 系统中的控制机制 (mechanism of Control) 如何运作. 例如，

1. 求值器没有解释子表达式的求值是**如何向使用该值的表达式返回值**的，
2. 也没有解释为什么一些递归过程生成了迭代运算过程（即使用常数空间求值, 尾递归），而其他递归过程生成递归过程。

这是因为元循环求值器本身依然是基于 lisp 运作的, 我们需要基于一个更加原始 (primitive) 更加底层的级别来做.

在本章中，我们将根据传统计算机的**分步操作**来描述过程。这种计算机或寄存器机按顺序执行指令，操作一组称为寄存器的固定存储元素的内容。

典型的寄存器机器指令将原始(primitive)操作应用于某些寄存器的内容，并将结果分配给另一个寄存器。 我们通过寄存器机器对过程的描述看起来会非常像是传统计算机中的 “机器语言”. 不过我们的这个语言相较于只能针对单一机器的机器语言相比显得更通用, 或者说更像是 DSL. 这使得我们所站的角度更像是一个 “硬件设计师” 而非 “机器语言程序猿”. 

在设计寄存器机时，我们将开发实现递归等重要编程构造的机制。我们还将介绍一种描述寄存器机器设计的语言。在 5.2 节我们会实现一个 lisp 程序, 它可以使用我们定义的描述去模拟我们设计的寄存器机器.

我们寄存器机器中大部分的原子操作都非常简单, 例如, 一个操作可能只是将从其他两个寄存器里存储的数字加总, 产生一个结果然后存到第三个寄存器里. 不过, 我们也会使用内存相关的操作, 例如 `car`, `cdr`, `cons` 等, 这些需要复杂的存储分配机制. 这将在 5.3 节中涉及

在 5.4 节中,  在我们已经积累了将简单过程构造成寄存器机器的经验后. 我们将设计一台机器，执行第4.1节元循环评估器描述的算法。通过为评估者的控制机械提供一个明确的模型，将填补我们对如何解释Scheme 表达式的理解的空白。

在第5.5节中，我们将研究一个简单的编译器，它将Scheme程序转换为可以直接与评估器寄存器机器的寄存器和操作一起执行的命令序列。

