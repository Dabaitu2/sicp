# Building Abstraction with Procedure

本章为我们讲解了最为基本的程序构造的概念。

### 1. The Elements of Programing
对于任何 powerful 的编程语言而言, 他们应该都具有三个核心能力
1. primitive expression: 基本操作，表达了语言所关心的最基本的实体, 例如数值，符号和算术运算
2. means of combination: 组合元素的方法，通过这个方法可以将简单的元素 (Elements) 组合成复合元素
3. means of Abstraction: 抽象的方法，通过这类方法我们可以为复合元素命名并且通过名字去操纵它们, 例如 lisp 中的 define

同时，我们关心的 Elements 主要是两种: Procedure & Data
但实际上，数据也是过程以及一些规则合并形成的，因此分得并没有那么开，这在第二章中会进一步阐述

程序设计的基本元素如下
1. Expression 表达式：当输入一个表达式, lisp 解释器会对这个表达式进行求值
2. Naming and Environment: 命名和环境, 通过命名我们指向可计算对象. 这也是最为简单和基本的抽象能力, 我们正是通过这种能力和组合能力协同去构造复杂程序. 
   为了能够在其他地方通过名字找到对应的可计算对象, 我们需要一个东西去存储这类关系, 这就是（全局）环境, 在其他地方还可能存在一些局部环境

除了这些实体,程序设计还要求有一些计算能力和组合能力
1. Evaluating Combinations 组合式求值: 对于 (op arg1 arg2), lisp 首先依次求解子表达式, 获得实际参数，并且将 op 实际对应的过程应用于相应的实际参数, 这样的过程是递归的
2. Compound procedure 复合过程: 我们所见过的最基本的过程 procedure 是 define, 算术运算。而将这些过程复合到一起，是一种更强大的抽象技术。但他本质上是很简单的概念,就是
   定义过程, 更通俗的来说，就是定义函数 (方法), 通过 (define (<name> <formal params>) <body>) 结合组合式求值，我们可以实现更复杂的过程复合。
   a. 在过程被执行时, 解释器如何工作也是需要考虑的一点。我们实际上使用的是 “替换模型”, 即将参数代换到过程中,并一步一步归约求值.
   b. 解释器通常使用的替换模型序列为应用序求值 (Applicative Order), 它会先求值参数再应用过程。而还有一种方案为将所有参数和过程全部替换后再计算, 称为正则序 (Normal Order), 后者
   在计算中可能出现重复计算的问题， 但在某些情况下，正则序会很有用，这会在第三，四章讲到

除了基本元素,抽象和组合,以及求值与复合能力之外
程序构造还需要提供条件表达式和 predicate 断言(谓词), 只有这样我们才能通过某些 test 的 result 去执行分支操作。

最后，为了降低编程的复杂度, 我们还要提供一些让过程作为黑盒抽象的能力,
简单来说,我们在实现一些复合过程时, 往往需要中间参数和中间过程, 然而我们不应该让使用者意识到它们的存在,因此要提供这类黑箱抽象能力
1. 过程形式参数的名字不应该让用户关心,因此要使用 local-name 去约束这类变量的生效范围。被约束在过程中的变量就是 **约束变量**, 而没有被形式参数约束的则为 **自由变量** (全局变量)
2. 中间过程的定义和使用不应让用户关心,因此要使用 块结构和内部定义 去隔离内部和外部, 而通过形式参数约束在外界过程中的变量, 
   反而可以作为这些内部过程中的自由变量(不写在形式参数里), 实现这套机制的方法就是词法作用域


### 2. Procedures and the Processes They Generate
本小节通过描述计算的 “形状”,  结合递归计算过程和迭代计算过程实例
来判断一个过程是否是耗时的, 并且给出了 ϴ 增长阶来度量过程
如果存在与n无关的整数k1 和 k2，使得:
$$k1f(n) <= R(n) <= k2f(n)$$ 对任何足够大的 n 都成立(R(n) 是 f(n) 的确界)，则 R(n)=ϴ(f(n)

### 3. Formulating Abstraction with Higher-Order Procedure
通过提供高阶函数能力,我们能进一步的增强抽象能力
高阶函数简单来说就是过程作为参数 / 返回值的过程

同时, 为了能够在使用过程中无须给一个名字就能应用高阶过程
我们还可以使用 lambda / let 表达式来直接刻画过程而无需给它一个名字

些抽象，使我们能像操作其他计算元素一样去操作它们。 一般而言，程序设计语言总会对计算元素的可能使用方式强加 上某些限制。
带有最少限制的元素被称为具有第一级的狀态(一等公民)。
第一级元素的某些“权利或者特权” 包括:

- 可以用变量命名;
- 可以提供给过程作为参数;
- 可以由过程作为结果返回;
- 可以包含在数据结构中。

Lisp 不像其他程序设计语言，它给了过程完全的第一级状态。这就给有效实现提出了挑战， 但由此所获得的描述能力却是极其惊人的 。

