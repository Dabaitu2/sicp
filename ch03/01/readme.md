# 3.1 Assignment and Local State

对世界做模拟的典型方式，是将其看作对象的集合，每个对象具有自己的内部状态，这个状态会随着时间变化。
例如一个银行账户的状态就可以包括其中的余额。而这个状态是会随着随时间流动而发生的交易动作发生改变的。

这样一个由诸多对象聚合的系统中，这些系统很少会是完全独立的, 他们或多或少都会通过 interaction 和其他对象产生关系。更加细节的来说, 这种 interaction 就是建立起一个对象的 状态 和其他对象的状态 的联系。
而我们可以将这种系统内的状态进行分组给不同的子系统，通过交互和其他子系统产生联系。

那么, 为了能够实现这种系统的模拟方式从而使得系统可以变得 modular,
我们必须要可以将现实问题分解为一批可计算对象 (computational object: 可以被放入程序变量中的东西都可以称为 computational object, 不要把它和计算机程序中的 object 名词混淆。) 并使得它们能够去模拟系统中的实际对象。

同时, 这些 computational object 应该还要具有 local state variables, 从而可以去描述它的状态。同时还需要 assignment operation 去保证数据状态有办法变化

---

个人总结：由于在这一章我们将视野从解决一个/一类问题转变为模拟一整个现实世界的系统,
不管是物理系统还是金融系统, 我们都需要较为形式化的理念去模拟他们,
将简单逻辑合并抽象为复杂逻辑的解决方法不足以解决系统模拟的问题。
因此我们需要模块化去进一步聚合和处理复杂系统。

我们还需要考虑如何模拟现实世界的时间变化。使用对象去模拟现实世界系统的前提下, 通常就是以程序一条条执行 (冯诺依曼架构) 的思路来模拟时间变化。

这小节主要是给出了基于对象方式模拟系统所需要引入的关键元素

1. 对象自身需要状态, 因此需要引入状态变量
2. 状态要可以随着时间(程序的运行)变化, 因此需要引入赋值 (Assignment) 操作

--
将赋值和局部状态引入我们的模拟系统带来的好处：

1. 我们可以将状态的保存隐藏在局部变量中，而不用显式的去操作其将其保存到其他地方或者在过程参数中传递, 这似乎有利于我们设计复杂系统

当然也有缺陷：

1. 应用这种方案使得代换模型不再生效,进一步来说，我们无法利用数学上具有漂亮性质的 **任何** 简单模型作为框架去设计程序了。也就是说我们必须向工程上进行妥协, 过程变得不纯
> 一个简单的例子便是我们对一个相同过程的多次调用，将无法获得稳定的结果。而本身可以获得稳定结果的设计方案就是函数式编程。
