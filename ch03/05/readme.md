# 3.5 Streams

Until Now, we have seen what problems will occur if we introduce Assignment.

1. Complexity with Time concept: the behavior of a program is no longer just determined by input, while what the status itself currently is still matters
2. The difficulty of understanding programs
3. Parallel programming issues: data inconsistent & deadlock
4. Referentially transparent was Broken: 在没有赋值的情况下，一个表达式可以被它所代表的结果替换掉而不改变程序的行为。但是在有赋值操作的情况下，这可能不再成立。

All of those problems are mainly due to we want to simulate this world's change by simulate our computed object with status which changed accompanied with time.

实际上，如果我们不要去让计算机时间和真实的时间形成对应的方式去形成对真实世界的模拟。
我们关心的如果不是 某一时刻某一个值是什么。 而是这整个变化周期内，这个值的变化历史。
那么我们就可以不需要强调这个变化发生在什么时候，只需要关注他们发生的顺序是否正确就好了。

因此，我们可以使用流 和 延时求值 技术来避免 assignment 引入的时间概念所带来的复杂性。
不过 Stream 也是有它自己的问题的。

## 3.5.1 Streams Are Delayed Lists
> 流就是延时的 Lists

在 2.2.3 章节中，我们通过 构造 sequence (序列, 数组).并且为其提供了许多抽象能力 (map, filter, accmulate)
从而实现了对许多不同的操作特征的抽象。

然而原先这样的使用在面对 list 的时候，可能会遇到低效的问题。这也是许多 函数式 代码的问题。
我们的数据从函数中进行传递的时候不可避免地遇到大量复制和构造。这样的操作是**批处理**的。
也就是说，我们在必须完成了第一个函数的所有数据处理，才能传给下一个。

然而实际上，我们在实际使用某个数据的时候，不是永远要使用其所有结果的，例如我们有一个 100w 长度的大数组，但是我们实际上要等到后面才会来使用这个数据的某个位置的值。那么求值和变动这个数组的后续部分本质上对于当前所需要的数据来说，代价就太大了。

如果我们能够通过某种策略，将求解后续部分数据的逻辑延后执行是非常有益的。这就依赖于一种**延时求值**的技术。也就是说，我们流中的元素，不会直接被求值，而是只有使用到的时候再求值。

这样的操作依赖 “delay” 和 ``force` 两个原始操作。本质上，就是将求值的操作通过 delay 包装到一个 lambda 函数中，只有调用到时，再使用 force 操作去求值。（同时这依赖一些类似宏的技术，也就是将代码看作数据，我们不应该在传入参数时就求值参数，也就是不可以直接使用应用序, 而是使用规范序进行求值）

## 3.5.2 Infinite Stream 无穷流

通过引入延时求值的特性，我们可以利用流实现一些常规过程无法实现的能力，例如一个 “无穷长度”的流。

实际上，无穷长度的流并不是真的无穷长度，而是他的长度随着我们的需要可以随意增长。

实现无穷流的策略通常是结合 递归 实现。下面是一个例子:

```scheme
(define ones (cons-stream 1 ones)) ;; 生成一个无穷的 1 构成的流
```

有时，无穷流的生成甚至是依赖于自己的前一个元素形成

```scheme
;;     1 1 2 3 5 8  13 21  (stream-cdr fibs)
;;     0 1 1 2 3 5  8  13  fibs
;; -------------------------------------------> time goes through
;; 0 1 1 2 3 5 8 13 21 34  fibs
(define fibs
  (cons-stream
   0
   (cons-stream 1 (add-stream (stream-cdr fibs) fibs))))
```



## 3.5.3 Exploiting The Stream Paradigm 

本节提供了一些通过流去替代赋值场景的实例。从而避免赋值所引入的程序设计语言中的一些理论麻烦。例如，

1. 通过无穷流，我们可以去模拟迭代, 从而用优雅的函数表现方式去求解一些数学问题。而不需要显式的去处理每一轮循环中的状态。
2. 我们在第二章中，通过利用对 cons 构成的序对的序列 (sequence of pairs) 进行操作，实现了针对传统循环操作的替代（也就是利用 map, enumerate, filter 等抽象接口去替代)。这样的操作过程实际上也很适合对无穷流做。而且，由于无穷流是‘无穷’的，这是寻常的循环接口 (比如一般的 for 循环) 无法做到的。例如，我们想获得一个流，其内容始终是满足 ` i <= j` 且 `i + j` 为素数的序对 `(i, j)` 。这就可以通过对无穷流进行序列操作(`stream-map`, `stream-filter` 等)来实现。
3. 由于流本身就是将数据视为信号，这对于解决现实中的信号处理系统的模拟尤为得心应手，例如，流很适合解决电路模拟问题。这里提供了 RLC 电路等实例。

### 3.5.4 流和延时求值

我们前面提到，要想使用流的能力，最重要的是实现其内部的 `delay` 能力，而实际上，为了使得流能够应付更多的程序设计需求，我们有时候需要显式的去调用 `delay` 结合流来实现某些能力。

例如, 在求解微分方程 $$dy/dt = f (y)$$ 时，我们可以将其表现为这样的一个 “电路” 模拟。

> 用数学语言来说，如果我们想要得到函数f(x)在点x=a处的导数（记为f'(a)或者df/dx|x=a），我们会考虑x从a增加一个非常小的值h时函数值f(x)的增加量，并且计算这个增加量与h之间比值（即[f(a+h)-f(a)]/h）当h趋向于0时的极限值。如果这个极限存在，则称f在a处可导，并且这个极限值就是导数。
>
> **微分**则更侧重于“增量”的概念。仍然考虑上面那个函数 $y=f(x$)，微分描述了当输入变量 $x$ 增加了一个非常小的量 $dx$ 时，输出变量 $y$ 增加了多少。我们通常将这个输出增加量称为 $dy$，并且 $dy$ 近似等于$f'(x)*dx$。这个 $dy/dx$ 所形成的方程就是微分方程中的 $f(y)$
>
> 求这个微分方程，本质上就是在已知导函数 $f(y)$ 的情况下， 找出原函数 $y = f(x)$
>
> 也就是要求出**导函数在极小增量上的积分（也就是原函数的差值）**的结果形成的流 

![image-20240108170826646](/Users/bytedance/Learning/CS/sicp/ch03/equation.png)

求一阶常微分方程时，本质上是对方程的两边同时求积分。

 其对应的代码实现可能是这样的：

```scheme
;; f 是 y 的某个函数, 本质上也就是那个导函数.
;; y0 是初值常数项，dt 是极小步长
;; 这里想做的就是通过对左侧求积分求出
(define (solve f y0 dt)
  ;; 通过积分求出每增长一个 dt (dx) 范围，原函数 y 的值
	(define y (integral dy y0 dt))  
  ;; 通过调用 f(y) 可以获得下一个 dy 也就是导函数增量
  (define dy (stream-map f y)) 
  y)
```

然而我们会发现，我们似乎需要在 dy 创建之前就在 y 的定义中使用它，这是做不到的。但实际上，在积分的实际使用中，第一步我们并不需要使用 dy. 这完全可以通过延时求值的策略获得。考虑如下的代码. 我们如果能够将 dy 通过 delay 包裹起来，那么它就不会被在传入参数时求值。只需要在需要它的时候再进行 force 就好了。

```scheme
(define (solve f y0 dt)
  (define y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)

(define (integral delayed-integrand initial-value dt)
  (define int
    (cons-stream
     initial-value
     (let ([integrand (force delayed-integrand)])
       (add-stream (scale-stream integrand dt) int))))
  int)

```

不过,  在编程中使用显式的 `delay` 和 `force` 可以增加程序设计的灵活性，但同时也会使得程序变得更复杂。
例如，书中提到的新版积分过程 `integral` 允许我们建模包含循环的系统，但是现在我们必须记住在调用 `integral` 时需要传入一个延迟计算的被积函数，而且任何使用 `integral` 的过程都必须意识到这一点。

实际上，这就创造了两类过程：普通过程和接受延迟参数的过程。通常情况下，创建不同类别的过程会迫使我们创建不同类别的高阶过程。为了避免需要两种不同类别的过程，作者提出了一个解决方案：使所有过程默认都接受延迟参数。在这个模型中，所有传递给过程的参数都会自动被延迟求值，并且只有在真正需要时（例如被原始操作所需时）才强制它们进行计算。

这将改变语言以使用正则序求值，并且如果我们只关心流处理，采用正则序求值将是一种统一且优雅地简化延迟求值使用的方法。

不幸地是，包含在过程调用中的延迟同依赖于事件顺序、使用赋值、变更数据或执行输入输出操作等能力的程序结合的话，就很容易造成混乱。即使是 `cons-stream` 中单独一个 `delay` 也可能引起极大混淆。

> **数据变更的 case**
>
> 假设我们希望对某一个可变数据结构做修改，比如一个 list，然而如果修改的操作被放到了 delay 里面
>
> 我们就没办法准确的估计这个修改的操作什么时候会生效了，而我们如果有什么地方对这个被修改后的数据结构存在强依赖，这样的结果就会变的非常麻烦且不可接受。
>
> **赋值的 case**
>
> 和数据变更差不多，如果我们的某个内部状态的更新操作被 delay 包裹了，那么我们如果在某些时刻按照某些顺序想去读取这个内部状态，其结果可能就不再正确了。
>
> **对时间顺序依赖的 case**
>
>  在某些程序中，特定操作必须按照严格定义好的顺序执行。例如，在多线程环境下对共享资源进行修改就必须非常小心地控制执行顺序以避免竞态条件（race conditions）。如果引入了延迟求值，则可能打破这种必要的顺序。
>
> **练习 3.51  的case**
>
> 我们针对某一个流的 stream-ref 的操作是难以预测的，特别是我们不清楚是否执行过这个流，而流中存在输入输出操作（比如打印，写文件，读文件）的话。
>
> 比如，我们定义了一个流，最初这个流只有第一个元素被求值，然而如果我们通过 stream-ref 去获取这个流中某个元素中后面的某个元素，那么流会被依次求值，那么这个流中如果有打印操作的话，这些打印操作就会被都执行一遍。然而，如果这个流已经被执行过了，那么这些流就不会再被求值，而是直接通过 memo 的存储的缓存被返回。对于流在不同状态下的调用依旧可能带来不同的副作用。

据目前所知，在编程语言中可变性和延迟执行并不很好地结合在一起，同时处理两者仍然是编程语言研究领域中一个活跃但尚未解决问题。



### 3.5.5 Modularity of Functional Programs and Modularity of Objects

前文所提到的引入赋值所带来的主要收益就是增强了模块化的能力。可以将一个大型系统的部分状态封装或者说隐藏到某一个局部模块中，使用流模型可以实现等价的模块化。

以求随机数为例子。下面分别展示了如何使用赋值和流模型实现对局部状态的封装

```scheme
(define rand
  (let ([x random-init])
    (lambda ()
      (set! x (rand-update x))
      x)))

(define random-numbers
  (cons-stream random-init
               (stream-map rand-update random-numbers)))
```

可以看到，通过使用流，我们不需要显示的实现一个 `rand` 方法（或者说，随机数生成器) 来通过每次调用获取一个新的随机数，而是直接生成一个随机数的流，其中下一个随机数由上一个随机数运行 update 生成。

使用流在解决并发问题时通常是很有效的, 它在保持了优雅的代换模型时, 消解了"对象"模拟的引入。又实现了使用内部状态一般的对外表现, 但是依然存在着需要解决的问题.

也就是，当我们的并发系统涉及到现实中多个独立对象之间的交互时, 它可能还是需要引入时间的概念

假设我们存在之前所提到的 "关联账户", 使用流来解决并发的访问账户时可能的顺序问题，实际需要对两个存取款操作的流进行 "merge", 然而，这个 merge 本身就是依赖现实世界的 时间顺序，我们不可以简单的让这两个流的操作一前一后的发生就好了, 因为我们无法保证这两个用户真的就这样操作。比如，有个账户的访问频率可能极低。我们不可能让另一个账户始终等待前一个账户存在结果再去执行。
我们往往还是需要根据现实操作的发生顺序来决定 merge 的顺序，这意味着我们还是不得不引入明确的 "时间" 的概念



### 结语

本章给出了模拟现实世界的复杂系统中所采用的两种基本的模块化思路：基于赋值，内部状态。抑或是基于流。这两者各有其强大之处。但就其自身而言，文没有一种方式能够完全令人满意。我们还在等待着一个大统一的出现。（这可能更多的是一个哲学问题，而不是一个计算机层面上的问题)



### P.s JS 中流的模拟和实现

在 JavaScript 中，并没有直接对应 SICP 中“流”的内置数据结构或特性。但是，JavaScript 有几种技术可以实现类似于流的概念：

1. **生成器 (Generators)**: ES6 引入了生成器函数，这种函数可以暂停执行并在稍后恢复，每次调用它的 `next()` 方法时返回序列中的下一个值。生成器提供了一种类似于 SICP 流的机制。

```javascript
function* naturalNumbers() {
    let num = 1;
    while (true) {
        yield num++;
    }
}

const numbers = naturalNumbers(); // 创建一个无限自然数序列
console.log(numbers.next().value); // 输出：1
console.log(numbers.next().value); // 输出：2
// ...可以按需继续获取下一个数...
```

2. **Promise 和异步函数**: Promise 和 async/await 是处理异步操作和延迟计算结果的技术。虽然它们不直接创建像流那样可以无限消费的数据结构，但它们提供了延迟计算结果直到需要它们为止。

3. **可观察对象 (Observables)**: 由 ReactiveX 库（如 RxJS）提供支持，在 JavaScript 中实现响应式编程。可观察对象可以表示随时间推移发出多个值的 Lazy pushing 集合。

4. **函数式编程库**: 如 Ramda 或 lodash/fp 提供了许多工具来处理集合和管道操作。这些库通常支持惰性求值，可以用来创建类似于流的行为。

5. **Streams API**: 虽然主要用于处理 I/O（例如文件系统和网络），Node.js 的 Streams API 提供了一种使用事件驱动方式来读写数据流。

以下是使用生成器模拟 SICP 中“流”思想的简单例子：

```javascript
// 使用 JavaScript 生成器定义一个范围内数字序列
function* range(start, end) {
    for (let i = start; i <= end; i++) {
        yield i;
    }
}

// 创建并消费这个序列
const numStream = range(1, 10);
for (let num of numStream) {
    console.log(num);
}
```

上述代码并不代表真正意义上无限延迟执行（除非去掉 `end` 条件），但能够体现按需消费数据序列中元素的基本思想。如果要模拟无限序列，则可以在生成器中使用 `while (true)` 循环，并适当管理资源以避免潜在问题。
