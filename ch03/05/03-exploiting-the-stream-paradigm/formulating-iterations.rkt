#lang sicp

(#%require "../../../common/data/stream.rkt")
(#%require "../../../common/math/num-theory.rkt")

(define (average x y)
  (/ (+ x y) 2))

;; 牛顿法
(define (sqrt-improve guess x)
  (average guess (/ x guess)))

;; 使用流来模拟迭代求根的过程
;; 简单分析一下 sqrt-stream 的过程
;;  -> guess = (cons-stream 1.0 (stream-map improve guess))
;;
;;  -> (stream-car guess) == 1.0
;;
;;  -> (stream-cdr guess)
;;    -> (stream-map sqrt-improve (cons-stream 1.0 (stream-map improve guess))) 
;;    -> (cons-stream 1.5 (stream-map sqrt-improve (stream-cdr (cons-stream 1.0 (stream-map improve guess)))))
;;
;;  -> (stream-car (stream-cdr guess)) == 1.5
;;
;;  -> (stream-cdr (stream-cdr guess)))
;;  -> (stream-cdr (cons-stream 1.5 (stream-map sqrt-improve (stream-cdr (cons-stream 1.0 (stream-map improve guess))))))
;;  -> (stream-map sqrt-improve (stream-cdr (cons-stream 1.0 (stream-map improve guess))))
;;  -> (stream-map sqrt-improve (cons-stream 1.5 (stream-map sqrt-improve (stream-cdr (cons-stream 1.0 (stream-map improve guess))))) 
;;  -> (const-stream 1.4166 (stream-map sqrt-improve (stream-cdr (cons-stream 1.5 (stream-map sqrt-improve (stream-cdr (cons-stream 1.0 (stream-map improve guess))))))))



;; (stream-cdr guess) -> (cons-stream 1.5 (stream-map sqrt-improve (stream-cdr (cons-stream 1.0 (stream-map improve guess)))))
;; (stream-cdr (stream-cdr guess)) -> (const-stream 1.4166 (stream-map sqrt-improve (stream-cdr (cons-stream 1.5 (stream-map sqrt-improve (stream-cdr (cons-stream 1.0 (stream-map improve guess))))))))
;; 可以看到每次取得流的元素本质上是在不停的展开
;; 有点反直觉的是，每次展开的新增项目实际上是在从最前面进入的, 也就是说，我们写在最后面的那个 guess 实际上永远不可能被转为实际的值
;; 这也是无穷流生成的要点：始终利用流的前一个元素生成后一个元素，但将后一个元素放在最前面 （cons-stream) 去增长这个流
;; 同时，本质上我们并不需要做这样复杂的展开，因为如果我们已经获得了某个流的第一项
;; 那么后面的项只是在第一项的前面不断的追加而已
;; 流不是通过存储状态来记忆数据的，它是通过从最初开始演化状态
;; 获取某个时间的数据的，因此理论上每次获取流的元素可能都挺费劲的
;; 所以我们之前的  delay 都会增加一层缓存优化，这样后续调用时就不用再算一次了
(define (sqrt-stream x)
  (define guesses
    (cons-stream 1.0
                 (stream-map (lambda (guess)
                               (sqrt-improve guess x))
                             guesses)))
  guesses)

(stream-refs 5 (sqrt-stream 2))


;; 求 π, 其可以表现为交替级数的形式 (正负项交替出现)
;; π/4 = 1 - 1/3 + 1/5 + 1/7 ....
;; 因此我们可以用流看作整体来逼近π
(define (pi-summands n)
  (cons-stream (/ 1.0 n)
               ;; 不停的利用递归：新的流的第一个元素来构造下一个元素
               ;; 同时不停的递归 stream-map 也会使得正负号恰好交替
               (stream-map - (pi-summands (+ n 2)))))

;; 求得 不断逼近 π/4 的交错级数增长所产生的流
(define (partial-sums s)
  (cons-stream (stream-car s)
               (add-stream (stream-cdr s)
                           (partial-sums s))))

;; x4 获得 pi 的逼近值
(define pi-stream
  (scale-stream (partial-sums (pi-summands 1)) 4))

;; 可以发现收敛的速度比较慢
(stream-refs 10 pi-stream)


;; 欧拉提出的序列加速器 对交错级数非常有效
;; 其每一项表现为：
;; 假设原有的序列为 S，第 n 项为 S_{n}, 则欧拉加速对应的项为
;; S_{n+1} - (S_{n+1} - S_{n})^2 / (S_{n-1} - 2S{n} + S_{n+1})
;; 它可以帮助交错级数快速收敛，不过它并不能够告诉我们收敛之后的每一项对应收敛前的哪一项
;; 但是通过这种方式，我们就可以在只知道 n-1, n, n+1 的原始项的情况下，获得某一个没有算出来过的非常远的交错级数地方的项
(define (euler-transform s)
  (let ((s0 (stream-ref s 0))
        (s1 (stream-ref s 1))
        (s2 (stream-ref s 2)))
    (cons-stream (- s2 (/ (square (- s2 s1))
                          (+ s0 (* -2 s1) s2)))
                 (euler-transform (stream-cdr s)))))

(stream-refs 10 (euler-transform pi-stream))


;; 而通过这样的方式产生的级数，也符合交错级数的概念(存在数学证明，我不会，所以跳过，但确认是存在的)。因此它们还可以进一步的被进行加速
;; 我们可以递归的加速这样的序列，去实现指数级加速
(define (make-tableau transform s)
  (cons-stream s
               (make-tableau transform (transform s))))


(define (accelerated-sequence transform s)
  (stream-map stream-car
              (make-tableau transform s)))


;; 只需要获得流中的第8项，我们就将这个级数收敛到 14 位精确值，如果使用原始级数慢慢算，我们要算到某一项小于 1/10^13 时才能获得
(stream-refs 10 (accelerated-sequence euler-transform pi-stream))


