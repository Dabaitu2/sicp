#lang sicp
(#%require "../../../common/data/stream.rkt")
(#%require "../../../common/math/num-theory.rkt")

;; section 2.2.3 tell us how to use sequence paradigm to handle tranditional loops as processes
;; defined on sequnces of pairs
;; 通过为对 pairs 的序列的一些过程操作来替代传统循环
;; 也就是用 map ， enumerate， filter， map 这类抽象数据接口

;; 而这种对 sequnce 操作的过程，也非常适合对无穷流做"循环计算"
;; 这是常规的循环难以做到的

;; 假设我们要获得一个无穷的 prime-sum-pairs 流
;; 这里不需要去实现 flatmap, 因为我们的序列是无穷的
;; 自然也不可能把它展开成一个有限序列
(define wip-int-pairs nil)
(define wip-prime-sum-pairs-stream
  (stream-filter (lambda (pair)
                   (prime? (+ (car pair) (cadr pair))))
                 wip-int-pairs))

;; 我们这里需要 int-pairs, 它是满足 i <= j 的所有整数对 (i, j) 的序列
;; 为了生成这样一个 int-pairs 序列
;; 假设我们有两个流 S, T
;; 本质上就还是要获得这样的无穷矩阵序列
;; (S0, T0) (S0, T1) (S0, T2) ...
;; (S1, T0) (S1, T1) (S1, T2) ...
;; (S2, T0) (S2, T1) (S2, T2) ...
;; ...
;;
;; 中的这一部分
;; (S0, T0) (S0, T1) (S0, T2) ...
;;          (S1, T1) (S1, T2) ...
;;                   (S2, T2) ...
;; 当 S, T 都是整数流时，我们就获得了 int-pairs

;; 我们分析我们需要的流的形状，可以发现它有三个部分构成
;; A | B
;; --+---
;;   | C
;;
;; A 自然就是 (S0, T0)
;; B 是第一行的其余元素
;; C 是剩余的所有元素。
;;
;; B 的获取方式为将 S 的 car 和 T 的 cdr 中的每一项进行组合
;; (stream-map (lambda (x) (list (stream-car s) x))
;;             (stream-cdr t))
;;
;; 而我们进一步分析 C，发现它本身是这样的
;; (S1, T1) (S1, T2) ...
;;          (S2, T2) ...
;;
;; 这正好又可以分为三个部分, 而且存在递归的特性, 因此本质上 C 就是一个递归调用获得
;; 那么我们就可以如下来定义所需的流
(define (some-way-to-append)
  (display "TODO"))
(define (wip-pairs s t)
  ;; part A
  (cons-stream (list (stream-car s) (stream-car t))
               ;; 这里的 some-way-to-append 需要去实现
               (some-way-to-append
                (stream-map (lambda (x)
                              (list (stream-car s) x))
                            (stream-cdr t))
                (wip-pairs (stream-cdr s) (stream-cdr t)))))

;; 一个朴素的想法是使用类似 append 的方式来做
(define (stream-append s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (stream-append (stream-cdr s1) s2))))

;; 但这样是不可行的，因为我们只有在将 s1 穷尽的情况下才会去组合 s2 中的元素
;; 例如 (pairs integers integers) 只会生成第一个元素为 1 的所有 pair.

;; 所以我们要重新涉及一种组合操作
;; 这里使用的是 interleave
;; 它交替的组合两个流中的元素 从而使得两个流中的元素都能够交错提供自己的数据
(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   ;; 这里就交换顺序，让递归的元素变成 s2， 从而让 s1 和 s2 交错
                   (interleave s2 (stream-cdr s1)))))

;; 这样就可以实现出我们所需要的流了
(define (pairs s t)
  (cons-stream
   ;; part A
   (list (stream-car s) (stream-car t))
   ;; 这里的 some-way-to-append 需要去实现
   (interleave (stream-map (lambda (x)
                             (list (stream-car s) x))
                           (stream-cdr t))
               (pairs (stream-cdr s) (stream-cdr t)))))

(stream-refs 23 (pairs integers integers))
