#lang sicp


;; 尝试对 (pairs integers integers) 中 pair 出现的规律做定量描述

;; 规律：每一排都无视第一个，第一个走对角线策略
;; (S0, T0)1 (S0, T1)2 (S0, T2)4 (S0, T3)6  (S0, T4)8  (S0, T5)10 12 14 18  第一排，每两个回来一次
;; (S1, T0)  (S1, T1)3 (S1, T2)5 (S1, T3)9  (S1, T4)13 (S1, T5)17           第二排，每四个回来一次
;; (S2, T0)  (S2, T1)  (S2, T2)7 (S2, T3)11 (S2, T4)19 (S2, T5)27           第三排, 每八个回来一次
;; (S3, T0)  (S3, T1)  (S3, T2)  (S3, T3)15 (S3, T4)23 (S3, T5)39
;; (S4, T0)  (S4, T1)  (S4, T2)  (S4, T3)   (S4, T4)31 (S4, T5)
;; ...                                                                   对角线: 2^n- 1 个时获得 (n, n)
;;
;;
;; i = 2^n-1  ==> (n, n)
;; i = 2n     ==> (1, 1+n)
;; i = 4n+1   ==> (2, 2+n)
;; i = 8n+3   ==> (3, 3+n)
;; i = 16n+7   ==> (4, 4+n)
;; i = 32n+15  ==> (5, 5+n)
;; i = 2^m * n + 2^(m-1) - 1 ===> (m, n)


;; answer:
;; for (m, n)
;; m = n ==> 2^m - 1
;; m != n ==> 2^m * (n-m) + 2^(m-1) - 1
;;        ==> 2^(m-1) * 2 * (n-m) + 2^(m-1) - 1
;;        ==> 2^(m-1) * (2 * (n - m) + 1) - 1


;; case: (3, 4) => 8 + 3 => 11
;; case: (4, 5) => 16 + 7 => 23
;; so (1, 100) => 2^100 - 1
;; 之前会有 2^100 个元素



