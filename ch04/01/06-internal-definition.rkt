#lang sicp


;; 考虑下面这样一个带有内部定义的过程

(define (f x)
  (define (even? n)
    (if (= n 0)
        true
        (odd? (- n 1))))
  (define (odd? n)
    (if (= n 0)
        false)
    (even? (- n 1)))
  (odd? x) 
  )


;; 在这里，我们想要的是 even 中调用的是函数 f 所建立的环境中的 odd
;; 对 odd 来说也是一样的，然而，我们目前的解释器实现并不能保证这是正确的
;; 因为我们的解释器是读一行，解析一行，求值一行，这意味着，如果我们在两个
;; 定义之间插入一些别的使用 even? 的代码，就可能导致
;; 1. 外部环境没有 odd，直接报错
;; 2. 外部环境有 odd，结果可能不符合我们的预期


;; 为了使实现我们需要的 "在建立 f 的环境时就立马建立好 even 和 odd 对应的变量"
;; 我们需要实现类似于 "同时创建变量" 的手段，也就是类似于变量提升的东西

;; 我们的实现可以考虑如下：
;; 求值表达式之前，在当前环境里建立起所有的局部变量，而非执行时再创建
;; 我们将过程变化为：先提升创建局部变量，将后续的操作转化为赋值

;; 例如:
;; (lambda <vars>)
;;   (define u <e1>)
;;   (define v <e2>)
;;   <e3>
;; )
;;
;; 可以被翻译为
;; (lambda <vars>
;;   (let ((u '*unassigned*)
;;         (v '*unassigned*))
;;     (set! u <e1>)
;;     (set! v <e2>)
;;     <e3>





