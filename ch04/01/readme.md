# 4.1 The Metacircular Evaluator

> 元循环求值器

元循环求值器本质上就是 3.2 节描述的环境模型的 scheme 实现
该模型包括两部分：

1. 求值一个组合表达式时，首先求解其中各自表达式，然后将值应用于外界表达式, 例如 `(* (+ 1 2) (- 4 2))` 中，先求解内部再求解外部
2. 将一序列实参应用于一个复合过程时，在一个新的环境中去求值这个过程体，而我们会使用一个 frame 去构造这个环境，并且在这个 frame 中存放形式参数和实际参数值的绑定

这两个规则描述了求值过程的本质，一个基本循环，在这个循环中，表达式在环境中求值被归约到将实际参数应用到过程上。而这一步又反过来归约到新的表达式在新的环境中求值，如此下去直到我们下降到遇到 symbols 也就是那些可以在环境中找到 binding 的变量/值，或者基本过程 `(+ 1 2)` 这种可以被直接应用而无需进一步归约的过程。

这个求值循环会由两个关键的过程相互作用形成：`eval` 和 `apply`

> 这样的循环其实就是:
> 将过程 apply 给参数 <=> **eval**uate 表达式

我们对于求值器的实现，依赖于一些定义了被求值的表达式的语法形式的过程。例如我们要定义什么情况是赋值，什么情况是加减乘除
什么情况是 if / cond 等。我们的实现是语言无关的。因此我们不是通过去检查某一个 表达式是不是以 `set!` 开头来决定其是不是赋值，而是通过一个通用的 predicate 过程 `assignment?` 去判断，同样的，我们使用 `assignment-variable` 和 `assignment-value` 去访问赋值中的相关部分

同时，我们还需要定义一些刻画过程和环境表示的操作。例如：`make-procedure` 会构造一个复合过程 `lookup-variable-value` 获取变量的值，`apply-primitive-procedure` 会将基本过程应用给一组实际参数
